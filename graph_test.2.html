<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" type="text/css" href="css/styles.css">
    <title>2D Analogy Graph</title>
  </head>
  <body>
    <div class="explainer">
      <h1 class="textCenter">Introduction to Search by Analogy (with Videogames)</h1>
      <div class="textCenter">
        <p>Imagine what fills in the blank:</p>
        <img src="./images/explainer/analogy.png" alt="analogy">
      </div>
      <p>
        The primary difference between the top two moments was that Mario was on foot (left) or riding Yoshi (right). The difference between the two moments on the left was that Mario was outdoors with a goomba (top), or indoors with Bowser (bottom). You were probably able to solve the analogy above, by imagining something like this to fill in the blank:
      </p>
      <img class="analogyMoment centerImage" src="./images/explainer/momentD.png" alt="momentD">
      <p>
        In this analogical solution, Mario is the indoors with Bowser (as on the bottom), and riding Yoshi instead of on foot (as on the right). If you’re a Mario fan you probably also noticed that these images aren’t from a real Mario game, but I bet that did not make it any harder to solve the analogy.
      </p>
      <p>
        This kind of analogical reasoning is easy for humans to do, but hard for them to explain, and it is not obvious that a machine can do it at all. Below, we show how a computer can be trained to understand this analogy, and provide an interactive example.
      </p>

      <!-- new section -->
      <h2>Parameterizing Videogame Moments</h2>
      <p>
        To a human being, each moment in a game has many features, but those features can also be broken down into numbers. In a Mario game this could include things like the number of coins collected, the number of enemies on the screen, the number of lives remaining, score, and so on:
      </p>
      <img class="diagram centerImage" src="./images/explainer/features.png" alt="features">
      <p>
        These are all the sort of things that we might pick out as features for a Mario game, but from now on let’s treat each of these as something a little more abstract (Feature X, Feature Y, etc.). The rest of this explanation works even if we have no idea what any of the individual features mean (e.g., if they are for an unfamiliar game, or if they were generated by machine learning). If we look at a graph of gameplay over time, we can see how each moment is a combination of these features:
      </p>
      <img class="diagram centerImage" src="./images/explainer/powerups.png" alt="powerups">
      <p>
        We can assign a numeric value to each feature and create a vector (list) of numbers to represent any specific videogame moment. Now each individual moment is just a long list of numbers:
      </p>
      <img class="diagram centerImage" src="./images/explainer/vectorRepresentation.png" alt="vectorRepresentation">
      <p class="caption textCenter">
        Credit to <a href="https://www.kdnuggets.com/2016/05/amazing-power-word-vectors.html">Adrian Colyer</a> for inspiring this illustration.
      </p>

      <!-- new section -->
      <p>
        So, why did we bother turning each moment in the game into a list of numbers? In short, because now we can do interesting things to these moments (with math), and what we can accomplish that way might surprise you.
      </p>
      <p>
        In reality our vectors will have many dimensions, but it will be easier to illustrate the rest of this explanation if we pretend that they only have two. In that case, our videogame moment vectors might look something like this.
      </p>

      <img class="diagram centerImage" src="./images/explainer/vectorAB.png" alt="vectorAB">

      <p>
        We can imagine a graph of Feature X (on the x-axis) and Feature Y (on the y-axis). If the game had only these two features, every possible moment would exist somewhere on this 2D graph. In this case we put Moment A and Moment B on the graph, from the example above.
      </p>
      <p>
        So, here’s the first part of how the search-by-anlogy trick works:
      </p>
      <p>
        We can take the difference between them to get a new vector (B-A) This vector removes what they have in common (Mario outdoors), but leaves intact what is distinct between them (on foot vs on Yoshi). The result of this operation (B-A) is a difference vector that we think represents something like the Yoshiness of that moment.
      </p>

      <img class="diagram centerImage" src="./images/explainer/vectorDifference.png" alt="vectorDifference">

      <p>
        Here’s the second part of the search-by-analogy trick:
      </p>
      <p>
        Now that we have a difference vector representing something like Yoshiness (B-A), we can add it to a moment that has no Yoshi in it (Moment C, from our example above), and hopefully find an equivalent moment with one crucial difference (the solution of to the analogy above, Moment C + Yoshi).
      </p>

      <img class="diagram centerImage" src="./images/explainer/newVector.png" alt="newVector">

      <p>
        That is the essence of videogame moment search-by-analogy, but there is one final important wrinkle, which is the part that makes this search. Although we can imagine a graph that contains all possible moments in a game, for most games we are only ever going to be working with a small sample of those moments. What if the moment we are looking for doesn’t exist in that sample? What if the moment that we are looking for isn’t even possible?
      </p>

      <img class="diagram centerImage" src="./images/explainer/queryVector.png" alt="queryVector">

      <p>
        In this case, we add the difference vector (B-A)  to another (Moment C) to create a query vector. Just as we said above, this is like adding the distinction we defined (Yoshiness) to Moment C. The only difference is that we are not quite done yet. Now, we just need to find the moment in our sample that is closest to our query vector.
      </p>

      <img class="diagram centerImage" src="./images/explainer/resultVector.png" alt="resultVector">

      <p>
        This is it, the closest moment to this query vector is our analogy search result, Moment D.  The interactive below contains examples of a search-by-analogy success for a couple of games. All of the moments used came from a human playthrough of each game (Super Mario World and Super Metroid). The graph shows, for every moment in the sample, its similarity to the difference vector (B-A, on the x-axis), its similarity to Moment C (on the y-axis) and how close it is to the query vector (dot size and color). You can scroll around the graph and mouse over any moment for more detail. You can also make your own queries (changing Moments A, B, and C) and see what happens:
      </p>
    </div>

    <div class="interactive">
      <div class="about">
        <h1>Search by Analogy Widget</h1>
        <p>An experiment in search by analogy for videogame moments. A is to B as C is to D.</p>
      </div>
      <div class="wrapper">
        <div class="frames-container">
          <div class="gallery">
            <img class="moment" id="imagetest1">
            <div class="moment-text">
              <label for="pointA">A:</label>
              <input class="frame-num" type="text" id="pointA" name="pointA">
            </div>
            <input class="pointRangeSlider" type="range" min="1" class="slider" id="myRangeA">
          </div>
          <div class="gallery">
            <img class="moment" id="imagetest2">
            <div class="moment-text">
              <label for="pointB">B:</label>
              <input class="frame-num" type="text" id="pointB" name="pointB">
            </div>
            <input class="pointRangeSlider"  type="range" min="1" class="slider" id="myRangeB">
          </div>
          <div class="gallery">
            <img class="moment" id="imagetest3">
            <div class="moment-text">
              <label for="pointC">C:</label>
              <input class="frame-num" type="text" id="pointC" name="pointC">
            </div>
            <input class="pointRangeSlider"  type="range" min="1" class="slider" id="myRangeC">
          </div>
          <div class="gallery result">
            <img class="moment" id="imagetest4">
            <div class="result-text">
              <div class="moment-text">
                <p>D: <span id="pointD"></span></p>
              </div>
            </div>
          </div>
        </div>

        <div class="graph-container">
          <div class="description">
            <i id="exampleTitle"></i>
            <p id="exampleDesc"><p>
          </div>
          <div class="buttons">
            <select id="gameListButton">
              <option value="mario">Mario</option>
              <option value="mario2">Mario2</option>
              <option value="metroid">Metroid</option>
            </select>
            <select id="kListButton">
              <option value="-1">-1</option>
              <option value="0.01">0.01</option>
              <option selected value="1">1</option>
              <option value="10">10</option>
            </select>
            <button id="exampleButton">Example 1</button>
            <button id="exampleButton2">Example 2</button>
            <button id="searchButton">Reset Graph</button>
          </div>

          <div id="scatter"></div>
        </div>
      </div>
    </div>

    <p class="footer caption">
      One final note: Our example is for videogame moments, but the properties that make this possible have also been demonstrated for <a href=https://jalammar.github.io/illustrated-word2vec/>text</a>, so we should be able to do it for anything that can be represented as a vector (e.g., music, images, etc.).
    </p>

    <script src="js/d3.v3.min.js"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.9.1/d3-tip.js"></script>
    <script src="js/vectorFunctions.js"></script>
    <script src="js/graph.js"></script>
  </body>
</html>
